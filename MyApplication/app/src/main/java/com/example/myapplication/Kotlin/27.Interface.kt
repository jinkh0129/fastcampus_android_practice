package com.example.myapplication.Kotlin

// 27. 인터페이스
// 상속을 사용하여 부모클래스의 기능을 자식클래스에서 수정하려고 할 때 override를 사용하는데 이것을 interface를 사용해서도 해결할 수 있다.
// 인터페이스는 약속!  --> 너가 이것을 구현하면 너도 이 타입이다!!!!!!!!
/*
상속은 Student라는 클래스가 Person클래스를 상속받으면 Person클래스의 기능들을 물려받는다. 그래서 상속을 하게되면 Person이 가진 기능들을 사용할 수 있다.
------------------------------------------------------------------------------------------------------------------------------------------------------------------------
반면, 인터페이스를 구현하게 되면 인터페이스를 구현하는 클래스는 인터페이스에 있는 함수들을 반드시 구현해줘야한다. 구현해준다는 것은 내용물을 채워주어야 한다는 것이다.
내용물을 채워준다는 것은 함수의 구체적인 기능들을 적어줘야 한다는 것이다.
 */
fun main(args: Array<String>) {
    val student_ : Student_ = Student_()
    student_.eat()
    student_.sleep()
}
interface Person_{ // interface의 문법은 조금 다르다.
    fun eat()
    fun sleep()
}
/*
<Interface>
(1) interface라는 키워드로 시작한다.
(2) 클래스는 생성자()가 들어가지만 인터페이스는 들어가지 않는다. 즉, 소괄호를 쓰지 않는다!
    --> 인스턴스화를 할 수 없음을 의미한다 = 설명서가 아님을 의미
(3) 인터페이스는 지침서의 의미다.
    --> "너가 이것을 구현하고 싶다면 [반드시] 아래의 기능을 구현해라!!!"
    --> 인터페이스 안의 함수에 내용({})이 없다.
 */

class Student_ : Person_{
    // 인터페이스를 받아서 안의 내용을 구현하려면 Generate에서 Implemented Methods를 해야한다.
    override fun eat() {

    }

    override fun sleep() {

    }
    // 이렇게 인터페이스 안의 함수를 구현해주면 Student_클래스도 Person_타입이다!!!
    // Person_을 구현한 클래스는 Person_의 타입이 된다.
}

class SoccerPlay : Person_{
    override fun eat() {
        TODO("Not yet implemented")
    }

    override fun sleep() {
        TODO("Not yet implemented")
    }
}

/*
1. 상속이 편리할 때
    --> 부모클래스의 내용을 자식클래스들이 공통으로 가지고 있을 때
    --> 구현할 필요없이 바로 쓸 때
    --> 아주 조금 수정이 필요할 때
2. 인터페이스가 편리할 때    
    --> 내용이 많이 달라서 수정이 많이 필요할 때(기능의 이름만 같고 세부적인 내용은 다를 때)
    --> 협업할 때 굉장히 유용하다
        --> 개발자들끼리 인터페이스를 정의하고
 */
